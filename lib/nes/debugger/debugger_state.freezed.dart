// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'debugger_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
  'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models',
);

/// @nodoc
mixin _$DebuggerState {
  bool get enabled => throw _privateConstructorUsedError;
  List<DisassemblyLine> get disassembly => throw _privateConstructorUsedError;
  int get PC => throw _privateConstructorUsedError;
  int get A => throw _privateConstructorUsedError;
  int get X => throw _privateConstructorUsedError;
  int get Y => throw _privateConstructorUsedError;
  int get SP => throw _privateConstructorUsedError;
  int get P => throw _privateConstructorUsedError;
  bool get C => throw _privateConstructorUsedError;
  bool get Z => throw _privateConstructorUsedError;
  bool get I => throw _privateConstructorUsedError;
  bool get D => throw _privateConstructorUsedError;
  bool get B => throw _privateConstructorUsedError;
  bool get V => throw _privateConstructorUsedError;
  bool get N => throw _privateConstructorUsedError;
  List<int> get stack => throw _privateConstructorUsedError;
  List<Breakpoint> get breakpoints => throw _privateConstructorUsedError;
  bool get canStepOut => throw _privateConstructorUsedError;
  int get scanline => throw _privateConstructorUsedError;
  int get cycle => throw _privateConstructorUsedError;
  int get v => throw _privateConstructorUsedError;
  int get t => throw _privateConstructorUsedError;
  int get x => throw _privateConstructorUsedError;
  bool get spriteOverflow => throw _privateConstructorUsedError;
  bool get sprite0Hit => throw _privateConstructorUsedError;
  bool get vBlank => throw _privateConstructorUsedError;
  bool get executionLogOpen => throw _privateConstructorUsedError;
  bool get showStack => throw _privateConstructorUsedError;

  /// Create a copy of DebuggerState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  $DebuggerStateCopyWith<DebuggerState> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $DebuggerStateCopyWith<$Res> {
  factory $DebuggerStateCopyWith(
    DebuggerState value,
    $Res Function(DebuggerState) then,
  ) = _$DebuggerStateCopyWithImpl<$Res, DebuggerState>;
  @useResult
  $Res call({
    bool enabled,
    List<DisassemblyLine> disassembly,
    int PC,
    int A,
    int X,
    int Y,
    int SP,
    int P,
    bool C,
    bool Z,
    bool I,
    bool D,
    bool B,
    bool V,
    bool N,
    List<int> stack,
    List<Breakpoint> breakpoints,
    bool canStepOut,
    int scanline,
    int cycle,
    int v,
    int t,
    int x,
    bool spriteOverflow,
    bool sprite0Hit,
    bool vBlank,
    bool executionLogOpen,
    bool showStack,
  });
}

/// @nodoc
class _$DebuggerStateCopyWithImpl<$Res, $Val extends DebuggerState>
    implements $DebuggerStateCopyWith<$Res> {
  _$DebuggerStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  /// Create a copy of DebuggerState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = null,
    Object? disassembly = null,
    Object? PC = null,
    Object? A = null,
    Object? X = null,
    Object? Y = null,
    Object? SP = null,
    Object? P = null,
    Object? C = null,
    Object? Z = null,
    Object? I = null,
    Object? D = null,
    Object? B = null,
    Object? V = null,
    Object? N = null,
    Object? stack = null,
    Object? breakpoints = null,
    Object? canStepOut = null,
    Object? scanline = null,
    Object? cycle = null,
    Object? v = null,
    Object? t = null,
    Object? x = null,
    Object? spriteOverflow = null,
    Object? sprite0Hit = null,
    Object? vBlank = null,
    Object? executionLogOpen = null,
    Object? showStack = null,
  }) {
    return _then(
      _value.copyWith(
            enabled:
                null == enabled
                    ? _value.enabled
                    : enabled // ignore: cast_nullable_to_non_nullable
                        as bool,
            disassembly:
                null == disassembly
                    ? _value.disassembly
                    : disassembly // ignore: cast_nullable_to_non_nullable
                        as List<DisassemblyLine>,
            PC:
                null == PC
                    ? _value.PC
                    : PC // ignore: cast_nullable_to_non_nullable
                        as int,
            A:
                null == A
                    ? _value.A
                    : A // ignore: cast_nullable_to_non_nullable
                        as int,
            X:
                null == X
                    ? _value.X
                    : X // ignore: cast_nullable_to_non_nullable
                        as int,
            Y:
                null == Y
                    ? _value.Y
                    : Y // ignore: cast_nullable_to_non_nullable
                        as int,
            SP:
                null == SP
                    ? _value.SP
                    : SP // ignore: cast_nullable_to_non_nullable
                        as int,
            P:
                null == P
                    ? _value.P
                    : P // ignore: cast_nullable_to_non_nullable
                        as int,
            C:
                null == C
                    ? _value.C
                    : C // ignore: cast_nullable_to_non_nullable
                        as bool,
            Z:
                null == Z
                    ? _value.Z
                    : Z // ignore: cast_nullable_to_non_nullable
                        as bool,
            I:
                null == I
                    ? _value.I
                    : I // ignore: cast_nullable_to_non_nullable
                        as bool,
            D:
                null == D
                    ? _value.D
                    : D // ignore: cast_nullable_to_non_nullable
                        as bool,
            B:
                null == B
                    ? _value.B
                    : B // ignore: cast_nullable_to_non_nullable
                        as bool,
            V:
                null == V
                    ? _value.V
                    : V // ignore: cast_nullable_to_non_nullable
                        as bool,
            N:
                null == N
                    ? _value.N
                    : N // ignore: cast_nullable_to_non_nullable
                        as bool,
            stack:
                null == stack
                    ? _value.stack
                    : stack // ignore: cast_nullable_to_non_nullable
                        as List<int>,
            breakpoints:
                null == breakpoints
                    ? _value.breakpoints
                    : breakpoints // ignore: cast_nullable_to_non_nullable
                        as List<Breakpoint>,
            canStepOut:
                null == canStepOut
                    ? _value.canStepOut
                    : canStepOut // ignore: cast_nullable_to_non_nullable
                        as bool,
            scanline:
                null == scanline
                    ? _value.scanline
                    : scanline // ignore: cast_nullable_to_non_nullable
                        as int,
            cycle:
                null == cycle
                    ? _value.cycle
                    : cycle // ignore: cast_nullable_to_non_nullable
                        as int,
            v:
                null == v
                    ? _value.v
                    : v // ignore: cast_nullable_to_non_nullable
                        as int,
            t:
                null == t
                    ? _value.t
                    : t // ignore: cast_nullable_to_non_nullable
                        as int,
            x:
                null == x
                    ? _value.x
                    : x // ignore: cast_nullable_to_non_nullable
                        as int,
            spriteOverflow:
                null == spriteOverflow
                    ? _value.spriteOverflow
                    : spriteOverflow // ignore: cast_nullable_to_non_nullable
                        as bool,
            sprite0Hit:
                null == sprite0Hit
                    ? _value.sprite0Hit
                    : sprite0Hit // ignore: cast_nullable_to_non_nullable
                        as bool,
            vBlank:
                null == vBlank
                    ? _value.vBlank
                    : vBlank // ignore: cast_nullable_to_non_nullable
                        as bool,
            executionLogOpen:
                null == executionLogOpen
                    ? _value.executionLogOpen
                    : executionLogOpen // ignore: cast_nullable_to_non_nullable
                        as bool,
            showStack:
                null == showStack
                    ? _value.showStack
                    : showStack // ignore: cast_nullable_to_non_nullable
                        as bool,
          )
          as $Val,
    );
  }
}

/// @nodoc
abstract class _$$DebuggerStateImplCopyWith<$Res>
    implements $DebuggerStateCopyWith<$Res> {
  factory _$$DebuggerStateImplCopyWith(
    _$DebuggerStateImpl value,
    $Res Function(_$DebuggerStateImpl) then,
  ) = __$$DebuggerStateImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call({
    bool enabled,
    List<DisassemblyLine> disassembly,
    int PC,
    int A,
    int X,
    int Y,
    int SP,
    int P,
    bool C,
    bool Z,
    bool I,
    bool D,
    bool B,
    bool V,
    bool N,
    List<int> stack,
    List<Breakpoint> breakpoints,
    bool canStepOut,
    int scanline,
    int cycle,
    int v,
    int t,
    int x,
    bool spriteOverflow,
    bool sprite0Hit,
    bool vBlank,
    bool executionLogOpen,
    bool showStack,
  });
}

/// @nodoc
class __$$DebuggerStateImplCopyWithImpl<$Res>
    extends _$DebuggerStateCopyWithImpl<$Res, _$DebuggerStateImpl>
    implements _$$DebuggerStateImplCopyWith<$Res> {
  __$$DebuggerStateImplCopyWithImpl(
    _$DebuggerStateImpl _value,
    $Res Function(_$DebuggerStateImpl) _then,
  ) : super(_value, _then);

  /// Create a copy of DebuggerState
  /// with the given fields replaced by the non-null parameter values.
  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? enabled = null,
    Object? disassembly = null,
    Object? PC = null,
    Object? A = null,
    Object? X = null,
    Object? Y = null,
    Object? SP = null,
    Object? P = null,
    Object? C = null,
    Object? Z = null,
    Object? I = null,
    Object? D = null,
    Object? B = null,
    Object? V = null,
    Object? N = null,
    Object? stack = null,
    Object? breakpoints = null,
    Object? canStepOut = null,
    Object? scanline = null,
    Object? cycle = null,
    Object? v = null,
    Object? t = null,
    Object? x = null,
    Object? spriteOverflow = null,
    Object? sprite0Hit = null,
    Object? vBlank = null,
    Object? executionLogOpen = null,
    Object? showStack = null,
  }) {
    return _then(
      _$DebuggerStateImpl(
        enabled:
            null == enabled
                ? _value.enabled
                : enabled // ignore: cast_nullable_to_non_nullable
                    as bool,
        disassembly:
            null == disassembly
                ? _value._disassembly
                : disassembly // ignore: cast_nullable_to_non_nullable
                    as List<DisassemblyLine>,
        PC:
            null == PC
                ? _value.PC
                : PC // ignore: cast_nullable_to_non_nullable
                    as int,
        A:
            null == A
                ? _value.A
                : A // ignore: cast_nullable_to_non_nullable
                    as int,
        X:
            null == X
                ? _value.X
                : X // ignore: cast_nullable_to_non_nullable
                    as int,
        Y:
            null == Y
                ? _value.Y
                : Y // ignore: cast_nullable_to_non_nullable
                    as int,
        SP:
            null == SP
                ? _value.SP
                : SP // ignore: cast_nullable_to_non_nullable
                    as int,
        P:
            null == P
                ? _value.P
                : P // ignore: cast_nullable_to_non_nullable
                    as int,
        C:
            null == C
                ? _value.C
                : C // ignore: cast_nullable_to_non_nullable
                    as bool,
        Z:
            null == Z
                ? _value.Z
                : Z // ignore: cast_nullable_to_non_nullable
                    as bool,
        I:
            null == I
                ? _value.I
                : I // ignore: cast_nullable_to_non_nullable
                    as bool,
        D:
            null == D
                ? _value.D
                : D // ignore: cast_nullable_to_non_nullable
                    as bool,
        B:
            null == B
                ? _value.B
                : B // ignore: cast_nullable_to_non_nullable
                    as bool,
        V:
            null == V
                ? _value.V
                : V // ignore: cast_nullable_to_non_nullable
                    as bool,
        N:
            null == N
                ? _value.N
                : N // ignore: cast_nullable_to_non_nullable
                    as bool,
        stack:
            null == stack
                ? _value._stack
                : stack // ignore: cast_nullable_to_non_nullable
                    as List<int>,
        breakpoints:
            null == breakpoints
                ? _value._breakpoints
                : breakpoints // ignore: cast_nullable_to_non_nullable
                    as List<Breakpoint>,
        canStepOut:
            null == canStepOut
                ? _value.canStepOut
                : canStepOut // ignore: cast_nullable_to_non_nullable
                    as bool,
        scanline:
            null == scanline
                ? _value.scanline
                : scanline // ignore: cast_nullable_to_non_nullable
                    as int,
        cycle:
            null == cycle
                ? _value.cycle
                : cycle // ignore: cast_nullable_to_non_nullable
                    as int,
        v:
            null == v
                ? _value.v
                : v // ignore: cast_nullable_to_non_nullable
                    as int,
        t:
            null == t
                ? _value.t
                : t // ignore: cast_nullable_to_non_nullable
                    as int,
        x:
            null == x
                ? _value.x
                : x // ignore: cast_nullable_to_non_nullable
                    as int,
        spriteOverflow:
            null == spriteOverflow
                ? _value.spriteOverflow
                : spriteOverflow // ignore: cast_nullable_to_non_nullable
                    as bool,
        sprite0Hit:
            null == sprite0Hit
                ? _value.sprite0Hit
                : sprite0Hit // ignore: cast_nullable_to_non_nullable
                    as bool,
        vBlank:
            null == vBlank
                ? _value.vBlank
                : vBlank // ignore: cast_nullable_to_non_nullable
                    as bool,
        executionLogOpen:
            null == executionLogOpen
                ? _value.executionLogOpen
                : executionLogOpen // ignore: cast_nullable_to_non_nullable
                    as bool,
        showStack:
            null == showStack
                ? _value.showStack
                : showStack // ignore: cast_nullable_to_non_nullable
                    as bool,
      ),
    );
  }
}

/// @nodoc

class _$DebuggerStateImpl implements _DebuggerState {
  const _$DebuggerStateImpl({
    this.enabled = false,
    final List<DisassemblyLine> disassembly = const [],
    this.PC = 0,
    this.A = 0,
    this.X = 0,
    this.Y = 0,
    this.SP = 0,
    this.P = 0,
    this.C = false,
    this.Z = false,
    this.I = false,
    this.D = false,
    this.B = false,
    this.V = false,
    this.N = false,
    final List<int> stack = const [],
    final List<Breakpoint> breakpoints = const [],
    this.canStepOut = false,
    this.scanline = 0,
    this.cycle = 0,
    this.v = 0,
    this.t = 0,
    this.x = 0,
    this.spriteOverflow = false,
    this.sprite0Hit = false,
    this.vBlank = false,
    this.executionLogOpen = false,
    this.showStack = false,
  }) : _disassembly = disassembly,
       _stack = stack,
       _breakpoints = breakpoints;

  @override
  @JsonKey()
  final bool enabled;
  final List<DisassemblyLine> _disassembly;
  @override
  @JsonKey()
  List<DisassemblyLine> get disassembly {
    if (_disassembly is EqualUnmodifiableListView) return _disassembly;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_disassembly);
  }

  @override
  @JsonKey()
  final int PC;
  @override
  @JsonKey()
  final int A;
  @override
  @JsonKey()
  final int X;
  @override
  @JsonKey()
  final int Y;
  @override
  @JsonKey()
  final int SP;
  @override
  @JsonKey()
  final int P;
  @override
  @JsonKey()
  final bool C;
  @override
  @JsonKey()
  final bool Z;
  @override
  @JsonKey()
  final bool I;
  @override
  @JsonKey()
  final bool D;
  @override
  @JsonKey()
  final bool B;
  @override
  @JsonKey()
  final bool V;
  @override
  @JsonKey()
  final bool N;
  final List<int> _stack;
  @override
  @JsonKey()
  List<int> get stack {
    if (_stack is EqualUnmodifiableListView) return _stack;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_stack);
  }

  final List<Breakpoint> _breakpoints;
  @override
  @JsonKey()
  List<Breakpoint> get breakpoints {
    if (_breakpoints is EqualUnmodifiableListView) return _breakpoints;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_breakpoints);
  }

  @override
  @JsonKey()
  final bool canStepOut;
  @override
  @JsonKey()
  final int scanline;
  @override
  @JsonKey()
  final int cycle;
  @override
  @JsonKey()
  final int v;
  @override
  @JsonKey()
  final int t;
  @override
  @JsonKey()
  final int x;
  @override
  @JsonKey()
  final bool spriteOverflow;
  @override
  @JsonKey()
  final bool sprite0Hit;
  @override
  @JsonKey()
  final bool vBlank;
  @override
  @JsonKey()
  final bool executionLogOpen;
  @override
  @JsonKey()
  final bool showStack;

  @override
  String toString() {
    return 'DebuggerState(enabled: $enabled, disassembly: $disassembly, PC: $PC, A: $A, X: $X, Y: $Y, SP: $SP, P: $P, C: $C, Z: $Z, I: $I, D: $D, B: $B, V: $V, N: $N, stack: $stack, breakpoints: $breakpoints, canStepOut: $canStepOut, scanline: $scanline, cycle: $cycle, v: $v, t: $t, x: $x, spriteOverflow: $spriteOverflow, sprite0Hit: $sprite0Hit, vBlank: $vBlank, executionLogOpen: $executionLogOpen, showStack: $showStack)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$DebuggerStateImpl &&
            (identical(other.enabled, enabled) || other.enabled == enabled) &&
            const DeepCollectionEquality().equals(
              other._disassembly,
              _disassembly,
            ) &&
            (identical(other.PC, PC) || other.PC == PC) &&
            (identical(other.A, A) || other.A == A) &&
            (identical(other.X, X) || other.X == X) &&
            (identical(other.Y, Y) || other.Y == Y) &&
            (identical(other.SP, SP) || other.SP == SP) &&
            (identical(other.P, P) || other.P == P) &&
            (identical(other.C, C) || other.C == C) &&
            (identical(other.Z, Z) || other.Z == Z) &&
            (identical(other.I, I) || other.I == I) &&
            (identical(other.D, D) || other.D == D) &&
            (identical(other.B, B) || other.B == B) &&
            (identical(other.V, V) || other.V == V) &&
            (identical(other.N, N) || other.N == N) &&
            const DeepCollectionEquality().equals(other._stack, _stack) &&
            const DeepCollectionEquality().equals(
              other._breakpoints,
              _breakpoints,
            ) &&
            (identical(other.canStepOut, canStepOut) ||
                other.canStepOut == canStepOut) &&
            (identical(other.scanline, scanline) ||
                other.scanline == scanline) &&
            (identical(other.cycle, cycle) || other.cycle == cycle) &&
            (identical(other.v, v) || other.v == v) &&
            (identical(other.t, t) || other.t == t) &&
            (identical(other.x, x) || other.x == x) &&
            (identical(other.spriteOverflow, spriteOverflow) ||
                other.spriteOverflow == spriteOverflow) &&
            (identical(other.sprite0Hit, sprite0Hit) ||
                other.sprite0Hit == sprite0Hit) &&
            (identical(other.vBlank, vBlank) || other.vBlank == vBlank) &&
            (identical(other.executionLogOpen, executionLogOpen) ||
                other.executionLogOpen == executionLogOpen) &&
            (identical(other.showStack, showStack) ||
                other.showStack == showStack));
  }

  @override
  int get hashCode => Object.hashAll([
    runtimeType,
    enabled,
    const DeepCollectionEquality().hash(_disassembly),
    PC,
    A,
    X,
    Y,
    SP,
    P,
    C,
    Z,
    I,
    D,
    B,
    V,
    N,
    const DeepCollectionEquality().hash(_stack),
    const DeepCollectionEquality().hash(_breakpoints),
    canStepOut,
    scanline,
    cycle,
    v,
    t,
    x,
    spriteOverflow,
    sprite0Hit,
    vBlank,
    executionLogOpen,
    showStack,
  ]);

  /// Create a copy of DebuggerState
  /// with the given fields replaced by the non-null parameter values.
  @JsonKey(includeFromJson: false, includeToJson: false)
  @override
  @pragma('vm:prefer-inline')
  _$$DebuggerStateImplCopyWith<_$DebuggerStateImpl> get copyWith =>
      __$$DebuggerStateImplCopyWithImpl<_$DebuggerStateImpl>(this, _$identity);
}

abstract class _DebuggerState implements DebuggerState {
  const factory _DebuggerState({
    final bool enabled,
    final List<DisassemblyLine> disassembly,
    final int PC,
    final int A,
    final int X,
    final int Y,
    final int SP,
    final int P,
    final bool C,
    final bool Z,
    final bool I,
    final bool D,
    final bool B,
    final bool V,
    final bool N,
    final List<int> stack,
    final List<Breakpoint> breakpoints,
    final bool canStepOut,
    final int scanline,
    final int cycle,
    final int v,
    final int t,
    final int x,
    final bool spriteOverflow,
    final bool sprite0Hit,
    final bool vBlank,
    final bool executionLogOpen,
    final bool showStack,
  }) = _$DebuggerStateImpl;

  @override
  bool get enabled;
  @override
  List<DisassemblyLine> get disassembly;
  @override
  int get PC;
  @override
  int get A;
  @override
  int get X;
  @override
  int get Y;
  @override
  int get SP;
  @override
  int get P;
  @override
  bool get C;
  @override
  bool get Z;
  @override
  bool get I;
  @override
  bool get D;
  @override
  bool get B;
  @override
  bool get V;
  @override
  bool get N;
  @override
  List<int> get stack;
  @override
  List<Breakpoint> get breakpoints;
  @override
  bool get canStepOut;
  @override
  int get scanline;
  @override
  int get cycle;
  @override
  int get v;
  @override
  int get t;
  @override
  int get x;
  @override
  bool get spriteOverflow;
  @override
  bool get sprite0Hit;
  @override
  bool get vBlank;
  @override
  bool get executionLogOpen;
  @override
  bool get showStack;

  /// Create a copy of DebuggerState
  /// with the given fields replaced by the non-null parameter values.
  @override
  @JsonKey(includeFromJson: false, includeToJson: false)
  _$$DebuggerStateImplCopyWith<_$DebuggerStateImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
